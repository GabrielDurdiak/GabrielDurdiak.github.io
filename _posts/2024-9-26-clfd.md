---
layout: post
title: Analysis of CVE-2024-21310 Pool Overflow Windows Cloud Filter Driver
---

This vulnerability is an Integer Overflow that is caused by a Numeric Truncation Error.

**What is a Numeric Truncation Error?**

Suppose we have a value of type int64_t and another value of type int16_t, and we want to add them together and store the result in a variable of type int16_t. This example will show how truncation occurs when storing the result in a data type with a smaller capacity.
``` c
int64_t large_value = 100000; 
int16_t small_value = 30000; 

int16_t sum = (int16_t)(large_value + small_value);

large_value is a 64-bit integer (int64_t) with a value of 100,000.
small_value is a 16-bit integer (int16_t) with a value of 30,000.
```
The sum of large_value and small_value is done on int64_t because it is the largest type. So the sum is:

100,000+30,000=130,000

The result of the sum (130,000) is then converted to int16_t. Since int16_t has a range of -32,768 to 32,767, any value outside this range will be truncated.


# Root cause of the Bug.

Vulnerable Windows version I used for this exploit:

![Image](/images/part14.png)

It is necessary to activate **Windows Long Path**. To do this, I followed the instructions in the following links:

https://www.microfocus.com/documentation/filr/filr-4/filr-desktop/t47bx2ogpfz7.html
https://www.autodesk.com/support/technical/article/caas/sfdcarticles/sfdcarticles/The-Windows-10-default-path-length-limitation-MAX-PATH-is-256-characters.html

First step we have to find the bug, for that I will do **bindiff** between the vulnerable version of cldfls.sys and the patched one.


The vulnerability is located in the **HsmFltProcessSetPinState** function.

``` c
  InformationFile = HsmiQueryFullFilePath(v22, v23, Object, 257i64, &PathSize); [1]
        HsmDbgBreakOnStatus((unsigned int)InformationFile);
        if ( InformationFile < 0 )
        {
          if ( WPP_GLOBAL_Control != (PDEVICE_OBJECT)&WPP_GLOBAL_Control
            && (HIDWORD(WPP_GLOBAL_Control->Timer) & 1) != 0
            && BYTE1(WPP_GLOBAL_Control->Timer) >= 2u )
          {
            WPP_SF_qqd(
              WPP_GLOBAL_Control->AttachedDevice,
              183i64,
              &WPP_78064aab483a35e2f1ef7b76ba44fd52_Traceguids,
              a2,
              v21,
              InformationFile);
          }
          goto LABEL_93;
        }
        v24 = PathSize + *(_WORD *)(a2 + 0x40); [2]
        LOWORD(v39) = 0;
        WORD1(v39) = v24;
        P = ExAllocatePoolWithTag(PagedPool, v24, 'sUsH'); [3]
        InformationFile = P == 0i64 ? 0xC000009A : 0;
        HsmDbgBreakOnStatus((unsigned int)InformationFile);
        if ( !P )
        {
          if ( WPP_GLOBAL_Control != (PDEVICE_OBJECT)&WPP_GLOBAL_Control
            && (HIDWORD(WPP_GLOBAL_Control->Timer) & 1) != 0
            && BYTE1(WPP_GLOBAL_Control->Timer) >= 2u )
          {
            WPP_SF_qd(
              WPP_GLOBAL_Control->AttachedDevice,
              184i64,
              &WPP_78064aab483a35e2f1ef7b76ba44fd52_Traceguids,
              a2,
              InformationFile);
          }
          goto LABEL_93;
        }
        memmove(P, *(const void **)(a2 + 72), *(unsigned __int16 *)(a2 + 64));
        LOWORD(v39) = *(_WORD *)(a2 + 64) - 2;
        memmove((char *)P + (unsigned __int16)v39, Src, (unsigned __int16)PathSize); [4]
```

<span style="color:red"> **[1]**</span>The **HsmiQueryFullFilePath** function returns in the **PathSize** variable the size of the path that we sent from NtCreateFIle.


<span style="color:red"> **[2]**</span>In this part of the code the integer overflow occurs because **PathSize** is **__int64, (a2 + 0x40)** is of type **WORD** which is **16 bits** (2 bytes) and the result is going to be stored in **unsigned __int16 v24 ( 2 bytes)**.
 so to produce an overflow, **PathSize** must be a **value large enough** so that the sum with 0x30 (the value of *(_WORD *)(a2 + 0x40)) **exceeds the 16-bit range when stored in v24.**

If **PathSize= 0xFFFC** and ** *(_WORD *)(a2 + 0x40)= 0x30 ** the result is **0x1002C** but in **v24** only 0x2c will be stored so v24=0x2c because only 2 bytes can be stored because the variable is of type **int16**.

<span style="color:red"> **[3]**</span>Then the result of the sum in **v24** will be used as size to allocate a chunk that will be of size **0x2c**

<span style="color:red"> **[4]**</span>In this part of the code, an **OOB write** will occur because in the chunk that was assigned before of size 0x2c, within that chunk, our **long path** of size 0xFFFC will be written and it uses the variable **PathSize=0xFFFC** as size.




# Vulnerability Patch

Let's see the patch that Microsoft applied to the function.

``` c
InformationFile = HsmiQueryFullFilePath(v22, v20, a3, 0x101u, PathSize);
    HsmDbgBreakOnStatus(InformationFile);
    if ( InformationFile < 0 )
    {
      v23 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (PDEVICE_OBJECT)&WPP_GLOBAL_Control
        || (HIDWORD(WPP_GLOBAL_Control->Timer) & 1) == 0
        || BYTE1(WPP_GLOBAL_Control->Timer) < 2u )
      {
        goto LABEL_99;
      }
      v24 = 213;
      goto LABEL_28;
    }
    pusResult[1] = *(_WORD *)(a2 + 0x40);
    if ( (unsigned int)Feature_2686352701__private_IsEnabled() )
    {
      InformationFile = RtlUShortAdd(pusResult[1], (USHORT)PathSize[0], &pusResult[1]); [1]
      if ( InformationFile < 0 )
      {
        v23 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (PDEVICE_OBJECT)&WPP_GLOBAL_Control
          || (HIDWORD(WPP_GLOBAL_Control->Timer) & 1) == 0
          || BYTE1(WPP_GLO


```

**[1]** The **RtlUShortAdd** function takes the two values **PathSize** and *(_WORD *)(a2 + 0x40) and checks whether the sum results in an overflow. If there is an overflow, the result is set to the maximum value of USHORT and an error code is returned. If there is no overflow, the result of the sum is saved in the supplied variable and 0 is returned to indicate success.

