---
layout: post
title: Analysis of CVE-2024-21310 Pool Overflow Windows Cloud Filter Driver
---

This vulnerability is an Integer Overflow that is caused by a Numeric Truncation Error.

**What is a Numeric Truncation Error?**

Suppose we have a value of type int64_t and another value of type int16_t, and we want to add them together and store the result in a variable of type int16_t. This example will show how truncation occurs when storing the result in a data type with a smaller capacity.
``` c
int64_t large_value = 100000; 
int16_t small_value = 30000; 

int16_t sum = (int16_t)(large_value + small_value);

large_value is a 64-bit integer (int64_t) with a value of 100,000.
small_value is a 16-bit integer (int16_t) with a value of 30,000.
```
The sum of large_value and small_value is done on int64_t because it is the largest type. So the sum is:

100,000+30,000=130,000

The result of the sum (130,000) is then converted to int16_t. Since int16_t has a range of -32,768 to 32,767, any value outside this range will be truncated.


# Root cause of the Bug.

Vulnerable Windows version I used for this exploit:

![Image](/images/part14.png)

It is necessary to activate **Windows Long Path**. To do this, I followed the instructions in the following links:

https://www.microfocus.com/documentation/filr/filr-4/filr-desktop/t47bx2ogpfz7.html
https://www.autodesk.com/support/technical/article/caas/sfdcarticles/sfdcarticles/The-Windows-10-default-path-length-limitation-MAX-PATH-is-256-characters.html

First step we have to find the bug, for that I will do **bindiff** between the vulnerable version of cldfls.sys and the patched one.


The vulnerability is located in the **HsmFltProcessSetPinState** function.

``` c
  InformationFile = HsmiQueryFullFilePath(v22, v23, Object, 257i64, &PathSize); [1]
        HsmDbgBreakOnStatus((unsigned int)InformationFile);
        if ( InformationFile < 0 )
        {
          if ( WPP_GLOBAL_Control != (PDEVICE_OBJECT)&WPP_GLOBAL_Control
            && (HIDWORD(WPP_GLOBAL_Control->Timer) & 1) != 0
            && BYTE1(WPP_GLOBAL_Control->Timer) >= 2u )
          {
            WPP_SF_qqd(
              WPP_GLOBAL_Control->AttachedDevice,
              183i64,
              &WPP_78064aab483a35e2f1ef7b76ba44fd52_Traceguids,
              a2,
              v21,
              InformationFile);
          }
          goto LABEL_93;
        }
        v24 = PathSize + *(_WORD *)(a2 + 0x40); [2]
        LOWORD(v39) = 0;
        WORD1(v39) = v24;
        P = ExAllocatePoolWithTag(PagedPool, v24, 'sUsH'); [3]
        InformationFile = P == 0i64 ? 0xC000009A : 0;
        HsmDbgBreakOnStatus((unsigned int)InformationFile);
        if ( !P )
        {
          if ( WPP_GLOBAL_Control != (PDEVICE_OBJECT)&WPP_GLOBAL_Control
            && (HIDWORD(WPP_GLOBAL_Control->Timer) & 1) != 0
            && BYTE1(WPP_GLOBAL_Control->Timer) >= 2u )
          {
            WPP_SF_qd(
              WPP_GLOBAL_Control->AttachedDevice,
              184i64,
              &WPP_78064aab483a35e2f1ef7b76ba44fd52_Traceguids,
              a2,
              InformationFile);
          }
          goto LABEL_93;
        }
        memmove(P, *(const void **)(a2 + 72), *(unsigned __int16 *)(a2 + 64));
        LOWORD(v39) = *(_WORD *)(a2 + 64) - 2;
        memmove((char *)P + (unsigned __int16)v39, Src, (unsigned __int16)PathSize); [4]
```
